/*
 * Generated by Arduino Visual Architect
 * -------------------------------------
 * Organized Structure: Includes -> Defines -> Globals -> Functions -> Setup -> Loop
 */

// --- LIBRARIES ---
/* [Includes] */
/* ====== INCLUDES ====== */
#include <Arduino.h>
#include <AccelStepper.h>
#include "HX711.h"
#include <SPI.h>
#include <MAX31856.h>
#include <Nextion.h>
#include <EEPROM.h>
#include <RBDdimmer.h>
  #include <math.h>

/* [Simulation Define] */
#define USE_MAX31856    0    // 1 = tanpa hardware, 0 = dengan hardwar
#define USE_HX711       1
#define USE_STEPPER     0

// ================== PIN ==================
#define RXD2 16
#define TXD2 17

/* [Nextion Serial Define] */
#define nexSerial Serial2   // tambahkan ini
// ---------- Config ----------


// ================== KONFIGURASI ==================
#define DEG_TO_RAD 0.01745329251
#define MIN_HEIGHT_DIFF        15.0   // mm
#define WALL_HEIGHT_THRESHOLD  40.0   // mm
#define OBJ_TIMEOUT_MS         500

// Kalibrasi objek speed
#define CAL_OBJ_LENGTH_CM     15.0
#define CAL_OBJ_TARGET_HEIGHT 50.0   // mm
#define CAL_HEIGHT_TOLERANCE  10.0   // mm
#define CAL_ANGLE_WINDOW      3

// ===== VOLUME CALIBRATION =====
#define CAL_OBJ_VOLUME_CM3   (15.0 * 15.0 * 5.0)  // 1125 cm3
float volumeScaleFactor = 1.0;
double volumeAccumDuringCal = 0;
bool volumeCalibrated = false;
double calAreaTime_ms = 0;   // cm2 * ms (integral area selama kalibrasi)

// ===== NOISE FILTER =====
#define HEIGHT_DEADBAND_MM        25.0   // mm, naikkan dari 15mm agar noise tidak dihitung
#define MIN_HITS_PER_SWEEP        8      // minimal jumlah sudut yang mendeteksi objek
#define MIN_SLICE_AREA_CM2        6.0    // area minimal agar dianggap objek (sebelumnya 2.0)
#define EMA_ALPHA                0.25f   // 0..1, makin kecil makin halus
#define EMPTY_HOLD_MS            3000    // ms, jika kosong stabil segini -> paksa area 0

/* [Motor Configuration Struct] */
struct MotorConfig {
  long speed;
  long accel;
  long steps;
  
};


/* [EEPROM Address Defines] */
/* ====== EEPROM ADDRESS ====== */
#define EEPROM_ADDR_WEIGHT_SET  0
#define EEPROM_ADDR_TIME_SET    4
#define EEPROM_ADDR_TEMP_SET    8  
#define EEPROM_ADDR_SCALE       12
#define EEPROM_ADDR_MOTOR_CFG   20 
#define EEPROM_ADDR_BLOWER_LEVEL (EEPROM_ADDR_MOTOR_CFG + 6 * sizeof(MotorConfig))


/* [MAX31856 Configuration Defines] */
/* ====== CONFIG MAX31856 ====== */
#define CR0_INIT  (CR0_AUTOMATIC_CONVERSION + CR0_OPEN_CIRCUIT_FAULT_TYPE_K + CR0_NOISE_FILTER_50HZ)
#define CR1_INIT  (CR1_AVERAGE_2_SAMPLES + CR1_THERMOCOUPLE_TYPE_S)
#define MASK_INIT (~(MASK_VOLTAGE_UNDER_OVER_FAULT + MASK_THERMOCOUPLE_OPEN_FAULT))

// ================== LIDAR VARIABLES ==================

float sliceAreaEma = 0;
unsigned long emptySince = 0;

volatile int dbg_hits = 0;
volatile float dbg_area_raw = 0;
volatile float dbg_area_ema = 0;
int hits = 0;


float backgroundDist[360];
float currentScan[360];

bool hasBackground = false;
float mountingHeight = 0;

int rightWallAngle = -1;
int leftWallAngle  = -1;

float conveyorSpeed = 0.05;   // cm/s
double totalVolume  = 0;      // cm3

unsigned long lastScanTime = 0;
unsigned long lastVolumePrintTime = 0;

bool speedCalibrated = false;
bool calibrateSpeedMode = false;
bool objMeasurementStarted = false;

unsigned long objStartTime = 0;
unsigned long lastObjectSeenTime = 0;

/* [Global Variables (Motor, Positions, Burner Logic, System State, Metrics, Manual Control, Blower)] */
    /* ====== VARIABLES ====== */
// Motor Control
long speed = 1000;
long accel = 200;
bool motorDoorBusy = false;
bool motorPushBusy = false;
bool motorAshBusy = false;
bool motorBurnerBusy = false;
bool motorBurnDoorBusy = false;
bool feederMotorOn = false;
bool weighingMotorOn = false;

const long POS_DOOR_OPEN      = 1200;
const long POS_DOOR_CLOSE     = 0;

const long POS_PUSH_IN        = 7100; // Posisi Feeder Masuk
const long POS_PUSH_OUT       = 0;    // Posisi Feeder Standby (Luar)

const long POS_BURNER_IN      = 3000; // Burner masuk ke ruang bakar
const long POS_BURNER_OUT     = 0;    // Burner standby diluar

const long POS_BDOOR_OPEN     = 1000; // Pintu Burner Buka
const long POS_BDOOR_CLOSE    = 0;    // Pintu Burner Tutup

const long POS_ASH_IN      = 3000; // Burner masuk ke ruang bakar
const long POS_ASH_OUT     = 0;    // Burner standby diluar

const long POS_MAINC_OPEN     = 1000; // Pintu Burner Buka
const long POS_MAINC_CLOSE    = 0;    // Pintu Burner Tutup



// Burner & Ignition Logic
bool burnerActive = false;
bool isPriming    = false;
bool burnTimerStarted = false;   

unsigned long burnerStartTime     = 0;
unsigned long lastCountdownUpdate = 0;
unsigned long ignitionDelayStart  = 0;
unsigned long now;
const unsigned long IGNITION_DELAY_MS = 10000;

// System State
bool autoModeEnabled = false;
enum SystemState {
  IDLE,
  WEIGHING,
  OPENING_MAIN_DOOR,
  DUMPING_IN,
  DUMPING_TRASH,
  DUMPING_OUT,
  CLOSING_MAIN_DOOR,

  OPENING_BURN_DOOR,
  BURNER_IN,
  IGNITING,
  BURNING,
  BURNER_OUT,
  CLOSING_BURN_DOOR,

  FAULT
};
SystemState currentState = IDLE;

int lastState = -1;



// Metrics & Sensor Data
float currentTempC = 0.0;
float currentWeightKg = 0.0;
unsigned long lastSensorMillis = 0;
const unsigned long SENSOR_INTERVAL = 2500;

float minBatchWeight = 5.0;
uint32_t burnerActiveTimeSec = 30;
const unsigned long DUMP_DURATION_MS = 10000;
unsigned long actionStartTime = 0;

float solarVolumeUsed_L = 0.0;
float totalConsumedKg = 0.0;
unsigned long totalBatchCount = 0;
const float LITERS_PER_HOUR_BURNER = 10.0;
float sfc_L_per_kg = 0.0;

const float OVERHEAT_TEMP = 1400.0;
float scale_factor = 397.0;
long scale_zero = 0;

long remaining = 0;
long last_remaining = -1;

// Logic Helper Manual
bool isManualOpen = true; // Status tombol OPEN/CLOSE (True=Open)
long manualSteps = 1000;  // Nilai default langkah stepper
long manualSpeed = 1000;  // Nilai default kecepatan
bool oneShotAutoMode = false; // [BARU] Untuk mode auto satu siklus via tombol b0

int blowLevel[3] = {0, 0, 0}; // Simpan status tiap blower
int blowTarget[3]  = {0, 0, 0};   // target power 0–100% per channel
int blowCurrent[3] = {0, 0, 0}; 

unsigned long lastBlowerFade = 0;
const unsigned long BLOWER_FADE_INTERVAL = 500;

float lastTempSent = -999;
float lastTempManSent = -999;
float lastWeightSent = -999;
float lastWeightManSent = -999;
float lastFuelSent = -999;
float lastTotalKgSent = -999;
unsigned long lastBatchSent = 999999;

long target = 0;

float massValue = 0;
byte outX1, outX2, outY1, outY2;

// Mapping tiap digit (harus disesuaikan dengan wiring kamu)
byte segDigit14[10] = { // digit 1 dan 4
  0b00101000, // 0
  0b01111110, // 1
  0b00110001, // 2  
  0b00110100, // 3
  0b01100110, // 4
  0b10100100, // 5
  0b10100000, // 6
  0b00111110, // 7
  0b00100000, // 8
  0b00100100  // 9
};

byte segDigit2[10] = { // digit 2 (dengan koma nyala)
  0b00001000, // 0
  0b01011110, // 1
  0b00010001, // 2  
  0b00010100, // 3
  0b01000110, // 4
  0b10000100, // 5
  0b10000000, // 6
  0b00011110, // 7
  0b00000000, // 8
  0b00000100  // 9
};

byte segDigit3[10] = { // digit 3
  0b00101000, // 0
  0b11101011, // 1
  0b00110001, // 2  
  0b10100001, // 3
  0b11100010, // 4
  0b10100100, // 5
  0b00100100, // 6
  0b11101001, // 7
  0b00100000, // 8
  0b10100000  // 9
};


/* [Nextion UI Objects] */
/* ====== NEXTION OBJECTS ====== */

NexPage page0 = NexPage(0, 0, "page0");  
NexPage page1 = NexPage(1, 0, "page1");
NexPage page2 = NexPage(2, 0, "page2"); 

// --- PAGE 0: DASHBOARD ---
NexText tStat       = NexText(0, 2, "tStat");    // Status Operasi
NexText tTemp       = NexText(0, 3, "tTemp");    // Suhu Ruang
NexText tWeight     = NexText(0, 4, "tWeight");  // Berat Muatan
NexText tTime       = NexText(0, 5, "tTime");    // Waktu Bakar (Realtime)
NexText tFuel       = NexText(0, 6, "tFuel");    // Est. BBM
NexText tBatch      = NexText(0, 7, "tBatch");   // Total Batch
NexText tTotWeight  = NexText(0, 8, "tTotWeight");// Total Weight
NexDSButton btAuto  = NexDSButton(0, 9, "btAuto");
//NexButton bStart    = NexButton(0, 9, "bStart");
NexButton bStop     = NexButton(0, 13, "bStop");
NexProgressBar jStat = NexProgressBar(0, 16, "jStat");
NexButton b1       = NexButton(0, 15, "b1");    


// --- PAGE 1: KONTROL MANUAL ====== */

NexDSButton btManDir   = NexDSButton(1, 2, "btManDir"); // 1=Close, 0=Open (Tergantung desainmu)

NexButton bManDoor     = NexButton(1, 4, "bManDoor");   // Pintu Utama
NexButton bManBDoor    = NexButton(1, 5, "bManBDoor");  // Pintu Burner
NexButton bManBurn     = NexButton(1, 6, "bManBurn");   // Burner Mover
NexButton bManPush     = NexButton(1, 20, "bManFeed");   // Feeder / Push
NexButton bManAsh      = NexButton(1, 7, "bManAsh");    // Ash Tray
NexDSButton bManMainC = NexDSButton(1, 18, "bManCon"); // Weighing Motor

NexSlider hManSpeed    = NexSlider(1, 8, "hManSpeed");  // Slider Speed
NexSlider hManStep     = NexSlider(1, 9, "hManStep");   // Slider Steps (Jarak)

NexDSButton btManBlow  = NexDSButton(1, 19, "btManBurn");  // Blower
NexDSButton btManIgn   = NexDSButton(1, 3, "btManIgn");   // Igniter
NexDSButton btManFeed  = NexDSButton(1, 99, "btManFeed");  // Feeder Motor
NexDSButton btManWeigh = NexDSButton(1, 98, "btManWeigh"); // Weighing Motor

NexText tManTemp       = NexText(1, 15, "tManTemp");
NexText tManWeight     = NexText(1, 16, "tManWeight");
NexButton bManStop     = NexButton(1, 14, "bManStop");
NexButton b0     = NexButton(1, 19, "b0");


/// --- PAGE 2: PENGATURAN [BARU] ---
// Display Angka
NexText nTempSet    = NexText(2, 22, "nTempSet");
NexText nTimeSet    = NexText(2, 21, "nTimeSet");
NexText nWeightSet  = NexText(2, 20, "nWeightSet");

// Tombol Plus Minus (Incremental)
NexButton bTempUp     = NexButton(2, 8, "bTempUp");
NexButton bTempDown   = NexButton(2, 9, "bTempDown");
NexButton bTimeUp     = NexButton(2, 7, "bTimeUp");
NexButton bTimeDown   = NexButton(2, 6, "bTimeDown");
NexButton bWeightUp   = NexButton(2, 5, "bWeightUp");
NexButton bWeightDown = NexButton(2, 4, "bWeightDown");

// Tombol Pilih Motor (Radio Button Logic)
NexDSButton bSelDoor  = NexDSButton(2, 27, "bSelDoor");
NexDSButton bSelBurn  = NexDSButton(2, 29, "bSelBurn");
NexDSButton bSelFeed  = NexDSButton(2, 28, "bSelFeed");
NexDSButton bSelBDoor = NexDSButton(2, 30, "bSelBDoor");
NexDSButton bSelAsh = NexDSButton(2, 33, "bSelAsh");
NexDSButton bSelMainC = NexDSButton(2, 32, "bSelMai");

// Slider Tuning
NexSlider hSpeed      = NexSlider(2, 11, "hSpeed");
NexSlider hStep       = NexSlider(2, 10, "hStep");

NexText tSpeed = NexText(2, 22, "tSpeed");
NexText tStep  = NexText(2, 23, "tStep");


// Tombol Blower (Low/Med/High/Off Logic)
NexButton bBlow1      = NexButton(2, 17, "bBlow1");
NexButton bBlow2      = NexButton(2, 17, "bBlow2");
//NexButton bBlow3      = NexButton(2, 16, "bBlow3");

NexText tBlow1 = NexText(2, 25, "tBlow1");
NexText tBlow2 = NexText(2, 26, "tBlow2");
//NexText tBlow3 = NexText(2, 28, "tBlow3");

// Tombol Save & Zero
NexButton bSave       = NexButton(2, 15, "bSave");
NexButton bZero       = NexButton(2, 12, "bZero");
NexText tWeightCal     = NexText(0, 18, "tWeightCal");  // Berat Muatan
NexButton bsettingStop       = NexButton(0, 13, "bsettingStop");

/* [Pin Configuration] */
/* ====== PIN CONFIG ====== */
// Sensor Pins
const int HX711_DT      = 38;
const int HX711_SCK     = 39;
const int MAX31856_CS   = 10;
const int MAX31856_SCK  = 13;
const int MAX31856_SDI  = 11;
const int MAX31856_SDO  = 12;

// SEVEN SEGMENT PINS (74HC595) 
#define DATA_PIN   18
#define CLOCK_PIN  19
#define LATCH_PIN  21

// Stepper Pins
// Stepper Pins (GANTI BAGIAN INI)
#define STEP_PIN_DOOR 26
#define DIR_PIN_DOOR 27
#define STEP_PIN_PUSH 99
#define DIR_PIN_PUSH 999
#define STEP_PIN_ASH 9999
#define DIR_PIN_ASH 5999
#define STEP_PIN_MAINC 4
#define DIR_PIN_MAINC 5

const int STEP_PIN_BURN   = 22; const int DIR_PIN_BURN    = 23;
const int STEP_PIN_BDOOR  = 24; const int DIR_PIN_BDOOR   = 25;
const int ENABLE_PIN    = 14;


// [BARU] Blower Pins (PWM Hardware)
const int PIN_BLOWER_1 = 44;
const int PIN_BLOWER_2 = 45;
const int PIN_BLOWER_3 = 46;
#define DIMMER_ZERO_CROSS_PIN 2

// AC Motor / Relay Pins
const int RELAY_BURNER         = 9;
const int RELAY_IGNITION       = 15;

/* [Default Motor Configurations] */
// Default Configs (Akan ditimpa EEPROM nanti)
MotorConfig motorConfigs[6] = {
  {1000, 200, 2000}, // 0: Door      (POS_DOOR_OPEN)
  {1000, 200, 5000}, // 1: Push      (POS_PUSH_IN)
  {1000, 200, 3000}, // 2: Burner    (POS_BURNER_IN)
  {800,  200, 1000}, // 3: BurnDoor  (POS_BDOOR_OPEN)
  {800,  200, 1000},  // 4: Ash       (sementara)
  {800,  200, 1000}  // 5: MAIN CONVEYOR       (sementara)
};
MotorConfig motorConfigsBase[6];


/* [Setting Variables] */
// Variabel selektor untuk layar Pengaturan
int selectedMotorIdx = 0;
uint8_t currentPage = 0;
bool motorSettingsDirty = false;
float tempSetpoint = 1200.0;

/* [Hardware Objects] */
/* ====== HARDWARE OBJECTS ====== */
HX711 scale;
AccelStepper stepperDoor(AccelStepper::DRIVER, STEP_PIN_DOOR, DIR_PIN_DOOR);
AccelStepper stepperPush(AccelStepper::DRIVER, STEP_PIN_PUSH, DIR_PIN_PUSH);
AccelStepper stepperAsh(AccelStepper::DRIVER, STEP_PIN_ASH, DIR_PIN_ASH);
AccelStepper stepperBurner(AccelStepper::DRIVER, STEP_PIN_BURN, DIR_PIN_BURN);
AccelStepper stepperBurnDoor(AccelStepper::DRIVER, STEP_PIN_BDOOR, DIR_PIN_BDOOR);
AccelStepper stepperMainConveyor(AccelStepper::DRIVER, STEP_PIN_MAINC, DIR_PIN_MAINC);
MAX31856 *temperature;
dimmerLamp blower1(PIN_BLOWER_1);    // TRIAC blower 1
dimmerLamp blower2(PIN_BLOWER_2);    // TRIAC blower 2
dimmerLamp blower3(PIN_BLOWER_3);    // TRIAC blower 3

/* [Nextion Listen List] */
NexTouch *nex_listen_list[] = {
  // Page events
  &page0, &page1, &page2,
  
  // --- Page 0: Dashboard ---
  &btAuto,  &bStop, &b1,
//&bStart,
  // Settings Page
  &nWeightSet, &nTimeSet, // (Ini objek sisa dr kode lama, boleh dihapus kalau tidak dipakai)
  &bTempUp, &bTempDown, &bTimeUp, &bTimeDown, &bWeightUp, &bWeightDown,
  &bSelDoor, &bSelBurn, &bSelFeed, &bSelBDoor, &bSelMainC, &bSelAsh, 
  &hSpeed, &hStep,
  &bBlow1, &bBlow2,&bsettingStop,
  &bSave, &bZero,

  // Manual Page
  &btManDir,  &bManMainC,
  &bManDoor, &bManBDoor, &bManBurn, &bManPush, &bManAsh,
  &hManSpeed, &hManStep, &bManStop,
  &btManBlow, &btManIgn, &btManFeed, &btManWeigh, &b0,
  NULL 
};


// ================== LIDAR HELPER ==================
float getHeightNearZeroDeg() {
  float maxH = 0;
  for (int i = 360 - CAL_ANGLE_WINDOW; i < 360; i++) {
    int idx = i % 360;
    if (backgroundDist[idx] > 0 && currentScan[idx] > 0) {
      float h = backgroundDist[idx] - currentScan[idx];
      if (h > maxH) maxH = h;
    }
  }
  for (int i = 0; i <= CAL_ANGLE_WINDOW; i++) {
    if (backgroundDist[i] > 0 && currentScan[i] > 0) {
      float h = backgroundDist[i] - currentScan[i];
      if (h > maxH) maxH = h;
    }
  }
  return maxH;
}

bool isValidCalibrationHeight(float h) {
  return (h >= CAL_OBJ_TARGET_HEIGHT - CAL_HEIGHT_TOLERANCE &&
          h <= CAL_OBJ_TARGET_HEIGHT + CAL_HEIGHT_TOLERANCE);
}

void processOneSweep() {
if (!hasBackground) return;

unsigned long now = millis();
unsigned long dt = now - lastScanTime;
lastScanTime = now;
if (dt > 200) dt = 100;

// ================== HITUNG LUAS IRISAN + NOISE FILTER ==================
float sliceAreaCM2_raw = 0;
int hitsLocal = 0;

for (int i = 0; i < 360; i++) {

  // Filter sudut conveyor (hanya dalam pagar)
  if (rightWallAngle >= 0 && leftWallAngle >= 0) {
    bool inConveyor = (i <= rightWallAngle) || (i >= leftWallAngle);
    if (!inConveyor) continue;
  }

  if (backgroundDist[i] <= 0 || currentScan[i] <= 0) continue;

  float heightDiff = backgroundDist[i] - currentScan[i];

  if (heightDiff <= HEIGHT_DEADBAND_MM) continue;   // deadband noise
  if (currentScan[i] < 80) continue;               // anti noise dekat lensa

  float arcWidth = currentScan[i] * DEG_TO_RAD;    // mm
  float areaElement = heightDiff * arcWidth;       // mm^2
  sliceAreaCM2_raw += areaElement;
  hitsLocal++;
}

sliceAreaCM2_raw /= 100.0f; // mm^2 -> cm^2

if (hitsLocal < MIN_HITS_PER_SWEEP) sliceAreaCM2_raw = 0;

// EMA smoothing
sliceAreaEma = (EMA_ALPHA * sliceAreaCM2_raw) + ((1.0f - EMA_ALPHA) * sliceAreaEma);

// Anti creep
if (sliceAreaEma < (MIN_SLICE_AREA_CM2 * 0.3f)) {
  if (emptySince == 0) emptySince = millis();
  if (millis() - emptySince > EMPTY_HOLD_MS) sliceAreaEma = 0;
} else {
  emptySince = 0;
}

float sliceAreaCM2 = sliceAreaEma;

// Debug globals
dbg_hits = hitsLocal;
dbg_area_raw = sliceAreaCM2_raw;
dbg_area_ema = sliceAreaEma;

// ================== DETEKSI OBJEK KALIBRASI (TINGGI ~5cm DI 0°) ==================
float h0 = getHeightNearZeroDeg();
bool validCal = isValidCalibrationHeight(h0);

// ================== MODE KALIBRASI SPEED + VOLUME SCALE ==================
if (calibrateSpeedMode) {

  if (validCal) {
    if (!objMeasurementStarted) {
      objMeasurementStarted = true;
      objStartTime = millis();
      lastObjectSeenTime = objStartTime;

      // Reset integral area-time untuk kalibrasi ini
      calAreaTime_ms = 0;

      // Reset smoothing supaya tidak “carry” dari kondisi sebelumnya
      sliceAreaEma = 0;
      emptySince = 0;

      Serial.print("CAL START | h0=");
      Serial.print(h0);
      Serial.println(" mm");
    }

    lastObjectSeenTime = millis();

    // KUMPULKAN integral area-time (pakai area yang sudah noise-filter dasar)
    // Pakai raw yang sudah min-hits (lebih responsif daripada EMA)
    if (sliceAreaCM2_raw > MIN_SLICE_AREA_CM2) {
      calAreaTime_ms += (double)sliceAreaCM2_raw * (double)dt; // cm2*ms
    }

  } else {
    if (objMeasurementStarted && (millis() - lastObjectSeenTime > OBJ_TIMEOUT_MS)) {

      float dur_s = (lastObjectSeenTime - objStartTime) / 1000.0f;
      if (dur_s < 0.05f) dur_s = 0.05f;

      // 1) Kalibrasi speed dari panjang 15cm
      conveyorSpeed = CAL_OBJ_LENGTH_CM / dur_s; // cm/s
      speedCalibrated = true;

      // 2) Hitung volume lidar dari speed * integral(area dt)
      //    V = speed * (calAreaTime_ms / 1000)
      double lidarVol = (double)conveyorSpeed * (calAreaTime_ms / 1000.0);

      // 3) Kalibrasi scale factor
      if (lidarVol > 50.0) { // minimal biar ga divide by noise
        volumeScaleFactor = (float)(CAL_OBJ_VOLUME_CM3 / lidarVol);
        volumeCalibrated = true;
      } else {
        volumeScaleFactor = 1.0f;
        volumeCalibrated = false;
      }

      Serial.print("CAL DONE | dur=");
      Serial.print(dur_s, 3);
      Serial.print(" s | speed=");
      Serial.print(conveyorSpeed, 3);
      Serial.print(" cm/s | lidarVol=");
      Serial.print(lidarVol, 2);
      Serial.print(" cm3 | scale=");
      Serial.println(volumeScaleFactor, 4);

      calibrateSpeedMode = false;
      objMeasurementStarted = false;
      lastVolumePrintTime = millis();
    }
  }

  for (int i = 0; i < 360; i++) currentScan[i] = 0;
  return;
}

// ================== VOLUME NORMAL ==================
if (!speedCalibrated || !volumeCalibrated) {
  for (int i = 0; i < 360; i++) currentScan[i] = 0;
  return;
}

if (sliceAreaCM2 > MIN_SLICE_AREA_CM2) {
  double dV = (double)sliceAreaCM2 * (double)conveyorSpeed * ((double)dt / 1000.0);
  totalVolume += dV * (double)volumeScaleFactor;
}

if (millis() - lastVolumePrintTime >= 1000) {
  lastVolumePrintTime += 1000;
  Serial.print("TOTAL VOLUME: ");
  Serial.print(totalVolume);
  Serial.println(" cm3");
}

for (int i = 0; i < 360; i++) currentScan[i] = 0;
}


void startBackgroundCalibration() {
  Serial.println("[Background Calibration]");
  float sum[360] = {0};
  int cnt[360] = {0};

  unsigned long t0 = millis();
  while (millis() - t0 < 3000) {
    if (Serial2.available() >= 5) {
      int b0 = Serial2.read();
      bool s1 = (b0 >> 1) & 1;
      bool s0 = b0 & 1;
      if (s1 == !s0) {
        byte buf[4];
        if (Serial2.readBytes(buf, 4) == 4) {
          float angle = ((buf[0] >> 1) | (buf[1] << 7)) / 64.0;
          float dist  = (buf[2] | (buf[3] << 8)) / 4.0;
          int idx = (int)angle;
          if (dist > 0 && idx >= 0 && idx < 360) {
            sum[idx] += dist;
            cnt[idx]++;
          }
        }
      }
    }
  }

  for (int i = 0; i < 360; i++)
    backgroundDist[i] = cnt[i] ? sum[i] / cnt[i] : 0;

  float hsum = 0; int hc = 0;
  int ref[] = {358,359,0,1,2};
  for (int i=0;i<5;i++) if (backgroundDist[ref[i]]>0) {hsum+=backgroundDist[ref[i]];hc++;}
  mountingHeight = hc ? hsum/hc : 0;
  hasBackground = true;

  rightWallAngle = -1;
  leftWallAngle  = -1;

  for (int i = 0; i < 80; i++) {
    float y = backgroundDist[i] * cos(i * DEG_TO_RAD);
    if ((mountingHeight - y) > WALL_HEIGHT_THRESHOLD) {
      rightWallAngle = i;
      break;
    }
  }

  for (int i = 360; i > 280; i--) {
    int idx = (i==360)?0:i;
    float y = backgroundDist[idx] * cos((360-idx) * DEG_TO_RAD);
    if ((mountingHeight - y) > WALL_HEIGHT_THRESHOLD) {
      leftWallAngle = idx;
      break;
    }
  }

  Serial.print("Right wall angle = "); Serial.println(rightWallAngle);
  Serial.print("Left  wall angle = "); Serial.println(leftWallAngle);
}


void resetLidar() {
  byte stopCmd[]  = {0xA5, 0x25};
  Serial2.write(stopCmd, 2);
  delay(100);

  byte startCmd[] = {0xA5, 0x20};
  Serial2.write(startCmd, 2);
}

// --- FUNCTIONS ---
/* [Emergency Stop Function] */
/* ====== UTILITIES ====== */

void emergencyStop() {
  // Matikan semua aktuator
  digitalWrite(RELAY_BURNER, LOW);
  burnerActive = false;
  burnTimerStarted = false;

  // Matikan motor AC
//  digitalWrite(RELAY_FEEDER_MOTOR, LOW);
  feederMotorOn = false;
//  digitalWrite(RELAY_WEIGHING_MOTOR, LOW);
  weighingMotorOn = false;

  // Hentikan dan nonaktifkan stepper
  digitalWrite(ENABLE_PIN, HIGH); // Disable stepper
  stepperDoor.stop();
  stepperPush.stop();
  stepperAsh.stop();
  stepperBurner.stop();
  stepperBurnDoor.stop();
  stepperMainConveyor.setSpeed(0);
}


// --- FUNGSI KIRIM KE 74HC595 ---
void sendByte(byte b) {
  digitalWrite(LATCH_PIN, LOW);
  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, b);
  digitalWrite(LATCH_PIN, HIGH);
}

void pesanError() {
  byte tandaMin = 0b11110111; 
  byte hurufE   = 0b10100001; 
  byte hurufR1  = 0b01111100; 
  byte hurufR2  = 0b10101011; 
  
  sendByte(~tandaMin); 
  sendByte(~hurufE); 
  sendByte(~hurufR1); 
  sendByte(~hurufR2); 
}

void convertTemperatureValueto7Segment(float tempValue) {

  if (tempValue > 1500.0f) {
    pesanError();
    return;
  }
  if (tempValue < 0) tempValue = 0;

  int tempIntVal = (int)tempValue;

  int tX1 = (tempIntVal / 1000) % 10;  // ribuan
  int tX2 = (tempIntVal / 100)  % 10;  // ratusan
  int tX3 = (tempIntVal / 10)   % 10;  // puluhan
  int tX4 = tempIntVal % 10;           // satuan

  const byte SEG_T_KOSONG = 0b11111111;

  byte tOut1, tOut2, tOut3, tOut4;

  tOut1 = (tX1 == 0) ? SEG_T_KOSONG : segDigit14[tX1];

  if (tX1 == 0 && tX2 == 0)
    tOut2 = SEG_T_KOSONG;
  else
    tOut2 = segDigit14[tX2];

  if (tX1 == 0 && tX2 == 0 && tX3 == 0)
    tOut3 = SEG_T_KOSONG;
  else
    tOut3 = segDigit3[tX3];

  tOut4 = segDigit14[tX4];

  sendByte(~tOut1);
  sendByte(~tOut2);
  sendByte(~tOut3);
  sendByte(~tOut4);
}

// ====== KONVERSI BERAT KE 7-SEG (format XX.xx) ======
void convertMassValueto7Segment(float massValue) {

  if (massValue > 250.0f) {
    pesanError();
    return;
  }

  if (massValue < 0) massValue = 0;

  int nilaiInt = (int)massValue;                      // contoh: 5
  int nilaiDec = (int)((massValue - nilaiInt) * 100); // contoh: 43

  int X1 = (nilaiInt / 10) % 10;  // puluhan
  int X2 = nilaiInt % 10;         // satuan
  int Y1 = (nilaiDec / 10) % 10;
  int Y2 =  nilaiDec % 10;

  if (nilaiInt < 10) {
    outX1 = 0b11111111;   // kosong
  } else {
    outX1 = segDigit14[X1];
  }

  outX2 = segDigit2[X2];
  outY1 = segDigit3[Y1];
  outY2 = segDigit14[Y2];

  sendByte(~outX1); // DIGIT 1
  sendByte(~outX2); // DIGIT 2
  sendByte(~outY1); // DIGIT 3
  sendByte(~outY2); // DIGIT 4
}

// --- FUNCTIONS ---
/* [Sensor Read, Metrics Compute, and HMI Update Functions] */

void readSensors() {
  if (currentState == FAULT) return;

#if USE_MAX31856
  currentTempC = temperature->readThermocouple(CELSIUS);
#else
  if (currentState == BURNING) {
    if (currentTempC < tempSetpoint) {
      currentTempC += 50;
      if (currentTempC > tempSetpoint) currentTempC = tempSetpoint;
    }
  } else {
    if (currentTempC > 20) {         
      currentTempC -= 50;
      if (currentTempC < 20) currentTempC = 20;
    }
  }

#endif

#if USE_HX711
  if (scale.is_ready()) {currentWeightKg = scale.get_units(1);}
#else
  if (currentState == WEIGHING) currentWeightKg += 1;
#endif
  if (currentTempC >= tempSetpoint) { // Pakai nilai dari setting
  }

#if USE_LIDAR
 if (Serial2.available() >= 5) {
    int b0 = Serial2.read();
    bool s1 = (b0 >> 1) & 1;
    bool s0 = b0 & 1;
    if (s1 == !s0) {
      byte buf[4];
      if (Serial2.readBytes(buf, 4) == 4) {
        float angle = ((buf[0] >> 1) | (buf[1] << 7)) / 64.0;
        float dist  = (buf[2] | (buf[3] << 8)) / 4.0;
        if (dist > 0) {
          int idx = (int)angle;
          if (idx >= 0 && idx < 360) currentScan[idx] = dist;
          static int lastAng = 0;
          if (lastAng > 340 && idx < 20) processOneSweep();
          lastAng = idx;
        }
      }
    }
  } 
#endif
}

void updateStateProgressBar() {
  uint8_t val = 0;   // 0–100

  switch (currentState) {
    // 1) WEIGHING: berdasarkan berat
    case WEIGHING: {
      if (minBatchWeight > 0) {
        float ratio = currentWeightKg / minBatchWeight;
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;
        val = (uint8_t)(ratio * 100.0f);
      } else {
        val = 0;
      }
      break;
    }

    // 2) OPENING / CLOSING MAIN DOOR: berdasarkan posisi stepperDoor
    case OPENING_MAIN_DOOR: {
      long pos = stepperDoor.currentPosition();
      if (pos < POS_DOOR_CLOSE) pos = POS_DOOR_CLOSE;
      if (pos > POS_DOOR_OPEN)  pos = POS_DOOR_OPEN;
      val = (uint8_t)((pos - POS_DOOR_CLOSE) * 100L / (POS_DOOR_OPEN - POS_DOOR_CLOSE));
      break;
    }

    case CLOSING_MAIN_DOOR: {
      long pos = stepperDoor.currentPosition();
      if (pos < POS_DOOR_CLOSE) pos = POS_DOOR_CLOSE;
      if (pos > POS_DOOR_OPEN)  pos = POS_DOOR_OPEN;
      // kebalikan: dari open ke close
      val = (uint8_t)((POS_DOOR_OPEN - pos) * 100L / (POS_DOOR_OPEN - POS_DOOR_CLOSE));
      break;
    }

    // 3) DUMPING_IN & DUMPING_OUT: posisi stepperPush
    case DUMPING_IN: {
      long pos = stepperPush.currentPosition();
      if (pos < POS_PUSH_OUT) pos = POS_PUSH_OUT;
      if (pos > POS_PUSH_IN)  pos = POS_PUSH_IN;
      val = (uint8_t)((pos - POS_PUSH_OUT) * 100L / (POS_PUSH_IN - POS_PUSH_OUT));
      break;
    }

    case DUMPING_OUT: {
      long pos = stepperPush.currentPosition();
      if (pos < POS_PUSH_OUT) pos = POS_PUSH_OUT;
      if (pos > POS_PUSH_IN)  pos = POS_PUSH_IN;
      val = (uint8_t)((POS_PUSH_IN - pos) * 100L / (POS_PUSH_IN - POS_PUSH_OUT));
      break;
    }

    // 4) DUMPING_TRASH: berdasarkan waktu DUMP_DURATION_MS
    case DUMPING_TRASH: {
      unsigned long elapsed = millis() - actionStartTime;
      if (elapsed > DUMP_DURATION_MS) elapsed = DUMP_DURATION_MS;
      val = (uint8_t)(elapsed * 100UL / DUMP_DURATION_MS);
      break;
    }

    // 5) BURN DOOR & BURNER IN/OUT: posisi stepperBurnDoor & stepperBurner
    case OPENING_BURN_DOOR: {
      long pos = stepperBurnDoor.currentPosition();
      if (pos < POS_BDOOR_CLOSE) pos = POS_BDOOR_CLOSE;
      if (pos > POS_BDOOR_OPEN)  pos = POS_BDOOR_OPEN;
      val = (uint8_t)((pos - POS_BDOOR_CLOSE) * 100L / (POS_BDOOR_OPEN - POS_BDOOR_CLOSE));
      break;
    }

    case CLOSING_BURN_DOOR: {
      long pos = stepperBurnDoor.currentPosition();
      if (pos < POS_BDOOR_CLOSE) pos = POS_BDOOR_CLOSE;
      if (pos > POS_BDOOR_OPEN)  pos = POS_BDOOR_OPEN;
      val = (uint8_t)((POS_BDOOR_OPEN - pos) * 100L / (POS_BDOOR_OPEN - POS_BDOOR_CLOSE));
      break;
    }

    case BURNER_IN: {
      long pos = stepperBurner.currentPosition();
      if (pos < POS_BURNER_OUT) pos = POS_BURNER_OUT;
      if (pos > POS_BURNER_IN)  pos = POS_BURNER_IN;
      val = (uint8_t)((pos - POS_BURNER_OUT) * 100L / (POS_BURNER_IN - POS_BURNER_OUT));
      break;
    }

    case BURNER_OUT: {
      long pos = stepperBurner.currentPosition();
      if (pos < POS_BURNER_OUT) pos = POS_BURNER_OUT;
      if (pos > POS_BURNER_IN)  pos = POS_BURNER_IN;
      val = (uint8_t)((POS_BURNER_IN - pos) * 100L / (POS_BURNER_IN - POS_BURNER_OUT));
      break;
    }

    // 6) IGNITING: berdasarkan waktu priming (IGNITION_DELAY_MS)
    case IGNITING: {
      if (isPriming) {
        unsigned long elapsed = millis() - ignitionDelayStart;
        if (elapsed > IGNITION_DELAY_MS) elapsed = IGNITION_DELAY_MS;
        val = (uint8_t)(elapsed * 100UL / IGNITION_DELAY_MS);
      } else {
        val = 0;
      }
      break;
    }

    // 7) BURNING: berdasarkan waktu burnerActiveTimeSec
    case BURNING: {
      unsigned long durationMS = burnerActiveTimeSec * 1000UL;
      unsigned long elapsed    = millis() - burnerStartTime;
      if (elapsed > durationMS) elapsed = durationMS;
      val = (uint8_t)(elapsed * 100UL / durationMS);
      break;
    }

    // default untuk IDLE & FAULT
    default:
      val = 0;
      break;
  }

  jStat.setValue(val);
}

void computeMetrics() {
  // Fuel Calculation: (Liter/Hour / 3600) * SecondsBurned * TotalBatches
  float literPerSec = LITERS_PER_HOUR_BURNER / 3600.0;
  float fuelPerBatch = literPerSec * burnerActiveTimeSec;
  solarVolumeUsed_L = totalBatchCount * fuelPerBatch;

  totalConsumedKg = totalBatchCount * minBatchWeight;
}

void updateHMI() {
  char buf[20]; // [FIX] Deklarasi dipindah ke paling atas
  // --- Temp Dashboard ---
  if (fabs(currentTempC - lastTempSent) > 0.5) {
    dtostrf(currentTempC, 3, 0, buf);
    tTemp.setText(buf);
    lastTempSent = currentTempC;
  }

  // --- Temp Manual Page ---
  if (fabs(currentTempC - lastTempManSent) > 0.5) {
    dtostrf(currentTempC, 3, 0, buf);
    tManTemp.setText(buf);
    lastTempManSent = currentTempC;
  }

  // --- Weight Dashboard ---
  if (fabs(currentWeightKg - lastWeightSent) > 0.5) {
    dtostrf(currentWeightKg, 4, 1, buf);
    tWeight.setText(buf);
    tWeightCal.setText(buf);
    lastWeightSent = currentWeightKg;
  }

  // --- Weight Manual Page ---
  if (fabs(currentWeightKg - lastWeightManSent) > 0.5) {
    dtostrf(currentWeightKg, 4, 1, buf);
    tManWeight.setText(buf);
    lastWeightManSent = currentWeightKg;
  }

  // Hitung ulang metrics
  computeMetrics();

  // --- Fuel / Solar Usage ---
  if (fabs(solarVolumeUsed_L - lastFuelSent) > 0.5) {
    dtostrf(solarVolumeUsed_L, 4, 1, buf);
    tFuel.setText(buf);
    lastFuelSent = solarVolumeUsed_L;
  }

  // --- Total Konsumsi KG ---
  if (fabs(totalConsumedKg - lastTotalKgSent) > 0.5) {
    dtostrf(totalConsumedKg, 4, 1, buf);
    tTotWeight.setText(buf);
    lastTotalKgSent = totalConsumedKg;
  }

  // --- Total Batch (integer, cek perubahan langsung) ---
  if (totalBatchCount != lastBatchSent) {
    snprintf(buf, sizeof(buf), "%lu", totalBatchCount);
    tBatch.setText(buf);
    lastBatchSent = totalBatchCount;
  }
  
  if (currentState != lastState) {
    switch (currentState) {
      case IDLE:          tStat.setText("IDLE");       break;
      case WEIGHING:      tStat.setText("WEIGHING");   break;
      case OPENING_MAIN_DOOR: tStat.setText("D.O"); break;
      case DUMPING_IN:     tStat.setText("F.IN");    break;
      case DUMPING_TRASH: tStat.setText("DUMP");    break;
      case DUMPING_OUT:    tStat.setText("F. OUT");   break;
      case CLOSING_MAIN_DOOR: tStat.setText("DOOR CLOSE"); break;
      
      case OPENING_BURN_DOOR: tStat.setText("B-DOOR OPEN"); break;
      case BURNER_IN:     tStat.setText("BURNER IN");  break;
      case IGNITING:      tStat.setText("IGNITING");   break;
      case BURNING:       tStat.setText("BURNING");    break;
      case BURNER_OUT:    tStat.setText("BURNER OUT"); break;
      case CLOSING_BURN_DOOR: tStat.setText("B-DOOR CLOSE"); break;
      
      case FAULT:         tStat.setText("FAULT");      break;
    }
    lastState = currentState;
  }
  updateStateProgressBar();

}

void initSettingPageTexts() {
  // --- Bagian suhu / waktu / berat ---
  showTempSet();
  showTimeSet();
  showWeightSet();

  // --- Bagian motor (selector, speed & step) ---
  // Pastikan motor yang aktif awal = 0 (Door)
  selectedMotorIdx = 0;
  updateMotorSelectorUI();
  updateSliderFromConfig();
  updateMotorInfoTexts();   // isi tSpeed & tStep

  // --- blower ---
  for (int i = 0; i < 3; i++) {
    // JANGAN reset blowLevel[i] di sini, pakai yang sudah dibaca dari EEPROM
    blowTarget[i]  = levelToPower(blowLevel[i]);
    blowCurrent[i] = blowTarget[i];
    updateBlowText(i);    // kirim teks "OFF/LOW/MED/HIGH" ke tBlow1/2/3
  }
}


// --- FUNCTIONS ---
/* [Motor Configuration & Selector Callbacks] */
//===================== Selector motor & slider ==============
void updateSliderFromConfig() {
  // Sinkronkan posisi slider dengan nilai tersimpan saat ganti motor
  hSpeed.setValue(motorConfigs[selectedMotorIdx].speed);
}

void bSelDoorPopCallback(void *ptr) {
  selectMotor(0);
}

void bSelFeedPopCallback(void *ptr) {
  selectMotor(1);
}

void bSelBurnPopCallback(void *ptr) {
  selectMotor(2);
}

void bSelBDoorPopCallback(void *ptr) {
  selectMotor(3);
}

void bSelAshPopCallback(void *ptr) {
  selectMotor(4);
}

void bSelMainCPopCallback(void *ptr) {
  selectMotor(5);
}

// Saat Slider digeser
void hSpeedPopCallback(void *ptr) {
  uint32_t val;
  hSpeed.getValue(&val);
  motorConfigs[selectedMotorIdx].speed = val; // Update variabel konfigurasi

  // Update langsung ke motor yang sesuai agar terasa efeknya
  if (selectedMotorIdx == 0) stepperDoor.setMaxSpeed(val);
  else if (selectedMotorIdx == 1) stepperPush.setMaxSpeed(val);
  else if (selectedMotorIdx == 2) stepperBurner.setMaxSpeed(val);
  else if (selectedMotorIdx == 3) stepperBurnDoor.setMaxSpeed(val);
  else if (selectedMotorIdx == 4) stepperAsh.setMaxSpeed(val);
  else if (selectedMotorIdx == 5) stepperMainConveyor.setMaxSpeed(val);


  motorSettingsDirty = true;   // <--- penting

  updateMotorInfoTexts();  
}

void hStepPopCallback(void *ptr) {
  uint32_t val;
  hStep.getValue(&val);

  // misal slider 0–100 map ke 0–20000 langkah
  long steps = map(val, 0, 100, 0, 100);
  motorConfigs[selectedMotorIdx].steps = steps;

  motorSettingsDirty = true;    // ada perubahan sementara di page setting

  updateMotorInfoTexts();       // refresh tStep
}


void applyMotorConfigsToSteppers() {
  stepperDoor.setMaxSpeed(motorConfigs[0].speed);
  stepperPush.setMaxSpeed(motorConfigs[1].speed);
  stepperBurner.setMaxSpeed(motorConfigs[2].speed);
  stepperBurnDoor.setMaxSpeed(motorConfigs[3].speed);
  stepperAsh.setMaxSpeed(motorConfigs[4].speed);
  stepperMainConveyor.setMaxSpeed(motorConfigs[5].speed);

  motorSettingsDirty = true;   // ada perubahan yang belum di-save EEPROM

}

// highlight DSButton sesuai motor yang terpilih
void updateMotorSelectorUI() {
  bSelDoor.setValue( selectedMotorIdx == 0 ? 1 : 0 );
  bSelFeed.setValue( selectedMotorIdx == 1 ? 1 : 0 );
  bSelBurn.setValue( selectedMotorIdx == 2 ? 1 : 0 );
  bSelBDoor.setValue( selectedMotorIdx == 3 ? 1 : 0 );
  bSelAsh.setValue( selectedMotorIdx == 4 ? 1 : 0 );
  bSelMainC.setValue( selectedMotorIdx == 5 ? 1 : 0 );

}

// fungsi umum untuk ganti motor terpilih
void selectMotor(uint8_t idx) {
  selectedMotorIdx = idx;
  updateMotorSelectorUI();

  updateSliderFromConfig();
  updateMotorInfoTexts(); 
}

void updateMotorInfoTexts() {
  char buf[16];

  // speed
  sprintf(buf, "%ld", motorConfigs[selectedMotorIdx].speed);
  tSpeed.setText(buf);

  // steps (span / jarak buka)
  sprintf(buf, "%ld", motorConfigs[selectedMotorIdx].steps);
  tStep.setText(buf);
}

void b0PopCallback(void *ptr) {
  // Aktifkan mode auto satu siklus dan mulai proses dari membuka pintu utama
  oneShotAutoMode = true;
  if (currentState == IDLE) {
    currentState = OPENING_MAIN_DOOR;
  }
}

// --- FUNCTIONS ---
/* [Scale Tare Function] */
void tareScale() {
  if (currentState != FAULT) {
#if USE_HX711
    scale.tare(20);
    scale_zero = scale.get_units(1);
#endif
  }
}


// --- FUNCTIONS ---
/* [Ignition Priming Check] */
void checkIgnitionPriming() {
  if (!isPriming) return;

  if (millis() - ignitionDelayStart >= IGNITION_DELAY_MS) {
    digitalWrite(RELAY_IGNITION, HIGH);
    isPriming = false;
    burnerActive = true;

    // Timer BELUM mulai sampai suhu capai setpoint
    burnerStartTime   = 0;
    burnTimerStarted  = false;

    currentState = BURNING;

  } else {
    long remaining = (IGNITION_DELAY_MS - (millis() - ignitionDelayStart)) / 1000;
    if (remaining != last_remaining) {
      last_remaining = remaining;
    }
  }
}

void checkFeederConveyor() {
  static bool conveyorRunning = false;

  if (currentState == FAULT || !autoModeEnabled) {
    if (conveyorRunning) {
      stepperMainConveyor.setSpeed(0);
      conveyorRunning = false;
    }
    return;
  }

  if (currentWeightKg < minBatchWeight) {

    if (!conveyorRunning) {
      digitalWrite(ENABLE_PIN, LOW);

      stepperMainConveyor.setMaxSpeed(motorConfigs[5].speed);
      stepperMainConveyor.setAcceleration(motorConfigs[5].accel);


      stepperMainConveyor.move(1000000L);

      conveyorRunning = true;
    }

  } else {

    if (conveyorRunning) {
      stepperMainConveyor.setSpeed(0);   
      conveyorRunning = false;
    }
  }
}



// --- FUNCTIONS ---
/* [EEPROM Settings Load/Save Functions] */
void loadSettings() {
  EEPROM.get(EEPROM_ADDR_WEIGHT_SET, minBatchWeight);
  EEPROM.get(EEPROM_ADDR_TIME_SET, burnerActiveTimeSec);
  EEPROM.get(EEPROM_ADDR_TEMP_SET, tempSetpoint);
 
   // Load Settingan Motor satu per satu
  MotorConfig defaults[6] = {
    {1000, 200, 2000},
    {1000, 200, 5000},
    {1000, 200, 3000},
    {800,  200, 1000},
    {800,  200, 1000},
    {800,  200, 1000}
  };
  
  for (int i = 0; i < 6; i++) {
    EEPROM.get(EEPROM_ADDR_MOTOR_CFG + (i * sizeof(MotorConfig)), motorConfigs[i]);

    // Sanity check: kalau data aneh, pakai default
    if (motorConfigs[i].speed < 0 || motorConfigs[i].speed > 50000 ||
        motorConfigs[i].steps < 0   || motorConfigs[i].steps > 200000) {
      motorConfigs[i] = defaults[i];
    }

    motorConfigsBase[i] = motorConfigs[i];
  }
  for (int i = 0; i < 3; i++) {
    uint8_t lvl;
    EEPROM.get(EEPROM_ADDR_BLOWER_LEVEL + i, lvl);

    // Sanity check: kalau di luar 0..3, anggap OFF
    if (lvl > 3) lvl = 0;

    blowLevel[i]   = lvl;
    blowTarget[i]  = levelToPower(lvl);
    blowCurrent[i] = blowTarget[i];   // start dari target supaya tidak "fade" dari 0

    updateBlowText(i);   // sync teks "OFF/LOW/MED/HIGH" di HMI
  }

  applyMotorConfigsToSteppers();
}

void saveSettings() {
  EEPROM.put(EEPROM_ADDR_WEIGHT_SET, minBatchWeight);
  EEPROM.put(EEPROM_ADDR_TIME_SET, burnerActiveTimeSec);
  EEPROM.put(EEPROM_ADDR_TEMP_SET, tempSetpoint);

  for (int i = 0; i < 6; i++) {
    EEPROM.put(EEPROM_ADDR_MOTOR_CFG + (i * sizeof(MotorConfig)), motorConfigs[i]);
    motorConfigsBase[i] = motorConfigs[i];   // baseline ikut di-update
  }
  for (int i = 0; i < 3; i++) {
    uint8_t lvl = (uint8_t)constrain(blowLevel[i], 0, 3);
    EEPROM.put(EEPROM_ADDR_BLOWER_LEVEL + i, lvl);
  }
  motorSettingsDirty = false;  // sudah commit
}

void discardUnsavedMotorSettings() {
  // kalau tidak ada perubahan, tidak perlu apa-apa
  if (!motorSettingsDirty) return;

  // kembalikan konfigurasi RAM dari baseline (EEPROM)
  for (int i = 0; i < 6; i++) {
    motorConfigs[i] = motorConfigsBase[i];
  }

  applyMotorConfigsToSteppers();
  updateSliderFromConfig();   // refresh slider sesuai motor terpilih
  motorSettingsDirty = false;
}

void page0PopCallback(void *ptr) {
  // Kalau sebelumnya dari page2 (Pengaturan) dan ada perubahan yang belum di-save, batalkan
  if (currentPage == 2) {
    discardUnsavedMotorSettings();
  }
  currentPage = 0;
}

void page1PopCallback(void *ptr) {
  if (currentPage == 2) {
    discardUnsavedMotorSettings();
  }
  currentPage = 1;
}

void page2PopCallback(void *ptr) {
  // Masuk ke halaman Pengaturan
  currentPage = 2;
  Serial.println("CURRENT PAGE 2");
  // Saat masuk, pastikan selector dan slider sinkron
  updateMotorSelectorUI();
  updateSliderFromConfig();
  updateMotorInfoTexts(); 
  initSettingPageTexts();
}

// --- FUNCTIONS ---
/* [Blower Control Functions and Callbacks] */
//====================== Blower ======================


//void setBlowerPWM(int pin, int level) {
//  int pwmVal = 0;
//  if (level == 1) pwmVal = 85;       // Low (~33%)
//  else if (level == 2) pwmVal = 170; // Med (~66%)
//  else if (level == 3) pwmVal = 255; // High (100%)
//  analogWrite(pin, pwmVal);
//}

void updateBlowerDimmer() {
  if (millis() - lastBlowerFade < BLOWER_FADE_INTERVAL) return;
  lastBlowerFade = millis();

  // Channel 0
  if (blowCurrent[0] < blowTarget[0]) blowCurrent[0] += 5;
  else if (blowCurrent[0] > blowTarget[0]) blowCurrent[0] -= 5;
  blowCurrent[0] = constrain(blowCurrent[0], 0, 100);
  blower1.setPower(blowCurrent[0]);

  // Channel 1
  if (blowCurrent[1] < blowTarget[1]) blowCurrent[1] += 5;
  else if (blowCurrent[1] > blowTarget[1]) blowCurrent[1] -= 5;
  blowCurrent[1] = constrain(blowCurrent[1], 0, 100);
  blower2.setPower(blowCurrent[1]);

  // Channel 2
  if (blowCurrent[2] < blowTarget[2]) blowCurrent[2] += 5;
  else if (blowCurrent[2] > blowTarget[2]) blowCurrent[2] -= 5;
  blowCurrent[2] = constrain(blowCurrent[2], 0, 100);
  blower3.setPower(blowCurrent[2]);
}

int levelToPower(int level) {
  switch (level) {
    case 0: return 40;   // OFF
    case 1: return 60;  // LOW
    case 2: return 80;  // MED
    case 3: return 95; // HIGH
  }
  return 0;
}

const char* levelToText(int level) {
  switch (level) {
    case 0: return "OFF";
    case 1: return "LOW";
    case 2: return "MED";
    case 3: return "HIGH";
  }
  return "OFF";
}

void updateBlowText(int id) {
  const char* txt = levelToText(blowLevel[id]);

  switch (id) {
    case 0:
      tBlow1.setText(txt);
      break;
    case 1:
      tBlow2.setText(txt);
      break;
//    case 2:
//      tBlow3.setText(txt);
//      break;
  }
}

void updateBlowerState(int id) {
  // Logic lama: tekan -> level naik 0/1/2/3 -> balik ke 0
  blowLevel[id]++;
  if (blowLevel[id] > 3) blowLevel[id] = 0;

  // Set target power untuk channel ini
  blowTarget[id] = levelToPower(blowLevel[id]);
  updateBlowText(id);

}


//void updateBlowerState(int id) {
//  // Logic: Tekan tombol -> Level naik -> Mentok balik ke 0 (Off)
//  blowLevel[id]++;
//  if (blowLevel[id] > 3) blowLevel[id] = 0;
//
//  int pin = (id == 0) ? PIN_BLOWER_1 : (id == 1) ? PIN_BLOWER_2 : PIN_BLOWER_3;
//  setBlowerPWM(pin, blowLevel[id]);
//}

void bBlow1PopCallback(void *ptr) { updateBlowerState(0); }
void bBlow2PopCallback(void *ptr) { updateBlowerState(1); }
void bBlow3PopCallback(void *ptr) { updateBlowerState(2); }


// --- FUNCTIONS ---
/* [Burner Timer Management] */
void checkBurnerTimer() {
  // Timer hanya relevan kalau burner ON dan di state BURNING
  if (!burnerActive || currentState != BURNING) return;

  unsigned long currentMillis = millis();

  // 1) Mulai timer HANYA setelah suhu mencapai setpoint
  if (!burnTimerStarted) {
    if (currentTempC >= tempSetpoint) {
      burnerStartTime  = currentMillis;
      burnTimerStarted = true;
    } else {
      // Belum mencapai setpoint -> tampilkan PREHEAT / WAIT
      tTime.setText("PRE HEAT");
      return;  // belum mulai ngitung durasi
    }
  }

  // 2) Kalau sudah mulai, jalankan hitungan mundur normal
  unsigned long durationMS = burnerActiveTimeSec * 1000UL;

  if (currentMillis - burnerStartTime >= durationMS) {
    burnerActive = false;
    burnTimerStarted = false;
    digitalWrite(RELAY_BURNER, LOW);
  }
  else if (currentMillis - lastCountdownUpdate >= 1000) {
    lastCountdownUpdate = currentMillis;

    unsigned long elapsed         = currentMillis - burnerStartTime;
    long remainingSeconds         = (durationMS - elapsed) / 1000;
    if (remainingSeconds < 0) remainingSeconds = 0;

    char timeBuf[10];
    sprintf(timeBuf, "%02ld:%02ld", remainingSeconds/60, remainingSeconds%60);
    tTime.setText(timeBuf);
  }
}


// --- FUNCTIONS ---
/* [Dashboard & General Nextion Callbacks] */
/* ====== NEXTION CALLBACKS ====== */

// --- 1. Dashboard & General ---
void btAutoPopCallback(void *ptr) {
  uint32_t dual_state;
  btAuto.getValue(&dual_state);
  if (dual_state == 1) {
    //Serial.println("AUTO START");
    autoModeEnabled = true;
    if (currentState == IDLE) {
      currentState = WEIGHING;
      tareScale();
    }
  } else {
    autoModeEnabled = false;
  }
}

//void bStartPopCallback(void *ptr) {
//  if (currentState == IDLE && autoModeEnabled) {
//      currentState = WEIGHING;
//      tareScale();
//  }
//}

void bStopPopCallback(void *ptr) {
  currentState = IDLE;
  emergencyStop();
}


// --- FUNCTIONS ---
/* [Stepper Actuation Utilities] */
//====================== Actuating Function ======================

void motorTurnCW(AccelStepper &motor, bool &busyFlag, long distance, long maxSpeedVal, long accelVal) {
  if (busyFlag) return;
  busyFlag = true;

  motor.setPinsInverted(false, false, false);
  motor.setMaxSpeed(maxSpeedVal);
  motor.setAcceleration(accelVal);
  motor.move(distance);
}

void motorTurnCCW(AccelStepper &motor, bool &busyFlag, long distance, long maxSpeedVal, long accelVal) {
  if (busyFlag) return;
  busyFlag = true;

  motor.setPinsInverted(true, false, false);
  motor.setMaxSpeed(maxSpeedVal);
  motor.setAcceleration(accelVal);
  motor.move(distance);
}


// --- FUNCTIONS ---
/* [Manual Control Relay Callbacks] */
// --- CALLBACK RELAY (ON/OFF) ---
//void btManBlowPopCallback(void *ptr) {
//  uint32_t val; btManBlow.getValue(&val);
//  if(val == 1) { 
//    setBlowerPWM(PIN_BLOWER_1, 3); setBlowerPWM(PIN_BLOWER_2, 3); setBlowerPWM(PIN_BLOWER_3, 3);
//  } else { 
//    setBlowerPWM(PIN_BLOWER_1, 0); setBlowerPWM(PIN_BLOWER_2, 0); setBlowerPWM(PIN_BLOWER_3, 0);
//  }
//}

void btManIgnPopCallback(void *ptr) {
  uint32_t val; btManIgn.getValue(&val);
  digitalWrite(RELAY_IGNITION, (val==1) ? LOW : HIGH); // Cek active low/high relaymu
}

void btManFeedPopCallback(void *ptr) {
  uint32_t val; btManFeed.getValue(&val);
//  digitalWrite(RELAY_FEEDER_MOTOR, (val==1) ? HIGH : LOW);
}

void btManWeighPopCallback(void *ptr) {
  uint32_t val; btManWeigh.getValue(&val);
//  digitalWrite(RELAY_WEIGHING_MOTOR, (val==1) ? HIGH : LOW);
}


// --- FUNCTIONS ---
/* [State Machine Runner] */
void runStateMachine() {
  switch (currentState) {
    case IDLE:              handleIdle(); break;
    case WEIGHING:          handleWeighing(); break;
    case OPENING_MAIN_DOOR: handleOpeningMainDoor(); break;
    case DUMPING_IN:        handleDumpingIn(); break;
//    case DUMPING_TRASH:     handleDumpingTrash(); break;
    case DUMPING_OUT:       handleDumpingOut(); break;
    case CLOSING_MAIN_DOOR: handleClosingMainDoor(); break;

    case OPENING_BURN_DOOR: handleOpeningBurnDoor(); break;
    case BURNER_IN:         handleBurnerIn(); break;
    case IGNITING:          handleIgniting(); break;
    case BURNING:           handleBurning(); break;
    case BURNER_OUT:        handleBurnerOut(); break;
    case CLOSING_BURN_DOOR: handleClosingBurnDoor(); break;

    case FAULT:             handleFault(); break;
  }
}


// --- FUNCTIONS ---
/* [Manual Control Stepper Callbacks] */
// --- 2. Manual Control ---
void btManDirPopCallback(void *ptr) {
  uint32_t val;
  btManDir.getValue(&val);
  isManualOpen = (val == 0); 
}

void hManSpeedPopCallback(void *ptr) {
  uint32_t val;
  hManSpeed.getValue(&val);
  manualSpeed = map(val, 0, 20, 0, 20000); 
}

void hManStepPopCallback(void *ptr) {
  uint32_t val;
  hManStep.getValue(&val);
  manualSteps = map(val, 0, 20, 0, 20000); 
}

// Fungsi Helper Gerak Manual
void runManualStepper(AccelStepper &motor) {
  if (currentState != IDLE) return; 
  digitalWrite(ENABLE_PIN, LOW); 
  motor.setMaxSpeed(manualSpeed);
  Serial.println(manualSpeed);
  motor.setAcceleration(200);
  
  long target = isManualOpen ? manualSteps : -manualSteps;
//  motor.run();
  motor.move(target);
  Serial.println(target); 
}
void runManualStepper2(AccelStepper &motor) {
  if (currentState != IDLE) return; 
  digitalWrite(ENABLE_PIN, LOW); 
  motor.setMaxSpeed(manualSpeed+1000);
  motor.setSpeed(manualSpeed);
  Serial.println(manualSpeed);
  
  long target = isManualOpen ? manualSteps : -manualSteps;
//  motor.run();
  // motor.move(target*1000);
  Serial.println(target*1000); 
  // motor.runSpeed();
}

//void runManualStepper1(AccelStepper &motor, long target) {
//  if (currentState != IDLE) return; 
//  digitalWrite(ENABLE_PIN, LOW); 
//  motor.setMaxSpeed(manualSpeed);
//  Serial.println(manualSpeed);
//  motor.setAcceleration(200);
//  
////  long target = isManualOpen ? manualSteps : -manualSteps;
////  motor.run();
//  motor.move(target);
//  motor.runToPosition(); 
//  Serial.println(target); 
//}


//void runManualStepper(AccelStepper &motor) {
////  if (currentState != IDLE) return; 
////  digitalWrite(ENABLE_PIN, LOW); 
////  stepperDoor.setMaxSpeed(1000);
////  Serial.println(manualSpeed);
////  stepperDoor.setAcceleration(200);
////  long target = isManualOpen ? manualSteps : -manualSteps;
//  stepperDoor.move(1000);
////  Serial.println(target); 
//}

// --- CALLBACK TOMBOL MOTOR ---

void bManDoorPopCallback(void *ptr)  { runManualStepper(stepperDoor);Serial.println("Mandoor"); }
void bManBDoorPopCallback(void *ptr) { runManualStepper(stepperBurnDoor); }
void bManBurnPopCallback(void *ptr)  { runManualStepper(stepperBurner); }
void bManPushPopCallback(void *ptr)  { runManualStepper(stepperPush); Serial.println("Pusher"); }
void bManAshPopCallback(void *ptr)   { runManualStepper(stepperAsh); }
void bManMainCPopCallback(void *ptr) { runManualStepper2(stepperMainConveyor); }



// --- FUNCTIONS ---
/* [Settings Page Display & Increment/Decrement Callbacks] */
// --- 3. Settings Page ---
void showTempSet() {
  char buf[16];
  sprintf(buf, "%d C", (int)tempSetpoint);
  nTempSet.setText(buf);
}

void showWeightSet() {
  char buf[16];
  sprintf(buf, "%d kg", (int)minBatchWeight);
  nWeightSet.setText(buf);
}

void showTimeSet() {
  char buf[16];
  // burnerActiveTimeSec disimpan dalam detik → tampilkan menit
  uint32_t menit = burnerActiveTimeSec / 60;
  sprintf(buf, "%lu min", (unsigned long)menit);   // "15 min"
  nTimeSet.setText(buf);
}



void bTempUpPopCallback(void *ptr) {
  tempSetpoint += 50.0;
  showTempSet();
}
void bTempDownPopCallback(void *ptr) {
  tempSetpoint -= 50.0;
  if (tempSetpoint < 0) tempSetpoint = 0;
  showTempSet();
}

void bTimeUpPopCallback(void *ptr) {
  burnerActiveTimeSec += 300; // +5 menit
  showTimeSet();
}
void bTimeDownPopCallback(void *ptr) {
  if (burnerActiveTimeSec >= 300) burnerActiveTimeSec -= 300;
  showTimeSet();
}


void bWeightUpPopCallback(void *ptr) {
  minBatchWeight += 1.0;
  showWeightSet();
}
void bWeightDownPopCallback(void *ptr) {
  if (minBatchWeight >= 1.0) minBatchWeight -= 1.0;
  showWeightSet();
}




void bZeroPopCallback(void *ptr) {
  if (currentState == IDLE || currentState == WEIGHING) {
    tareScale();
  }
}

void bSavePopCallback(void *ptr) {
  saveSettings(); // Panggil fungsi save EEPROM
}

void nWeightSetPopCallback(void *ptr) {
  char buf[16] = {0};
  nWeightSet.getText(buf, sizeof(buf)-1);
  // atof akan berhenti saat ketemu huruf (k, g, spasi), jadi "5 kg" masih aman
  minBatchWeight = atof(buf);
  EEPROM.put(EEPROM_ADDR_WEIGHT_SET, minBatchWeight);
  showWeightSet();   // refresh supaya formatnya rapi "x kg"
}


void nTimeSetPopCallback(void *ptr) {
  char buf[16] = {0};
  nTimeSet.getText(buf, sizeof(buf)-1);
  uint32_t menit = (uint32_t)atoi(buf);   // baca angka awal
  burnerActiveTimeSec = menit * 60;       // simpan dalam detik
  EEPROM.put(EEPROM_ADDR_TIME_SET, burnerActiveTimeSec);
  showTimeSet();
}




// --- FUNCTIONS ---
/* [State Handler Functions] */
/* ====== STATE HANDLERS ====== */

void handleIdle() {
  //  emergencyStop();
//  Serial.println("aaa");
  if (stepperDoor.currentPosition() != POS_DOOR_CLOSE) {
    digitalWrite(ENABLE_PIN, LOW);
    stepperDoor.moveTo(POS_DOOR_CLOSE);
  } else {
    digitalWrite(ENABLE_PIN, HIGH);
  }
}

void handleWeighing() {
  if (currentWeightKg >= minBatchWeight) {
    currentState = OPENING_MAIN_DOOR;
  }
}

void handleOpeningMainDoor() {
#if USE_STEPPER
  digitalWrite(ENABLE_PIN, LOW);
  stepperDoor.moveTo(POS_DOOR_OPEN);
  if (stepperDoor.distanceToGo() == 0 && stepperDoor.currentPosition() == POS_DOOR_OPEN) {
    currentState = DUMPING_IN;
  }
#else
  // SIMULASI
  stepperDoor.setCurrentPosition(POS_DOOR_OPEN);
  currentState = DUMPING_IN;
#endif
}


void handleDumpingIn() {
#if USE_STEPPER
  stepperPush.moveTo(POS_PUSH_IN);
  if (stepperPush.distanceToGo() == 0) {
    actionStartTime = millis();
    currentState = DUMPING_OUT;
  }
#else
  stepperPush.setCurrentPosition(POS_PUSH_IN); 
  actionStartTime = millis();
  currentState = DUMPING_OUT;
#endif
}


void handleDumpingOut() {
#if USE_STEPPER
  stepperPush.moveTo(POS_PUSH_OUT);
  if (stepperPush.distanceToGo() == 0) {
    currentState = CLOSING_MAIN_DOOR;
  }
#else
  stepperPush.setCurrentPosition(POS_PUSH_OUT);
  currentState = CLOSING_MAIN_DOOR;
#endif
}



void handleClosingMainDoor() {
#if USE_STEPPER
  stepperDoor.moveTo(POS_DOOR_CLOSE);
  if (stepperDoor.distanceToGo() == 0) {
    tareScale();
    currentState = OPENING_BURN_DOOR;
  }
#else
  stepperDoor.setCurrentPosition(POS_DOOR_CLOSE);
  tareScale();
  currentState = OPENING_BURN_DOOR;
#endif
}


// 6. Buka Pintu Burner
void handleOpeningBurnDoor() {
#if !USE_STEPPER
  stepperBurnDoor.setCurrentPosition(POS_BDOOR_OPEN);
  currentState = BURNER_IN;
#else
  stepperBurnDoor.moveTo(POS_BDOOR_OPEN);
  if (stepperBurnDoor.distanceToGo() == 0 && stepperBurnDoor.currentPosition() == POS_BDOOR_OPEN) {
    currentState = BURNER_IN;
  }
#endif
}


void handleBurnerIn() {
#if !USE_STEPPER
  stepperBurner.setCurrentPosition(POS_BURNER_IN);
  currentState = IGNITING;
#else
  stepperBurner.moveTo(POS_BURNER_IN);
  if (stepperBurner.distanceToGo() == 0 && stepperBurner.currentPosition() == POS_BURNER_IN) {
    currentState = IGNITING;
  }
#endif
}

void handleIgniting() {
  // Ignition Sequence
  if (!isPriming) {
    digitalWrite(RELAY_IGNITION, LOW); // Trigger Spark
    isPriming = true;
    ignitionDelayStart = millis();

    digitalWrite(RELAY_BURNER, HIGH);  // Fuel ON
    burnerActive = true;

    totalBatchCount++;
    computeMetrics();
  }
}


void handleBurning() {
  // Kalau burner sudah dimatikan oleh checkBurnerTimer -> lanjut
  if (!burnerActive) {
    burnTimerStarted = false;  // reset flag untuk siklus berikutnya
    currentState = BURNER_OUT;
  }
}

void handleBurnerOut() {
#if !USE_STEPPER
  stepperBurner.setCurrentPosition(POS_BURNER_OUT);
  currentState = CLOSING_BURN_DOOR;
#else
  stepperBurner.moveTo(POS_BURNER_OUT);
  if (stepperBurner.distanceToGo() == 0 && stepperBurner.currentPosition() == POS_BURNER_OUT) {
    currentState = CLOSING_BURN_DOOR;
  }
#endif
}


void handleClosingBurnDoor() {
#if !USE_STEPPER
  stepperBurnDoor.setCurrentPosition(POS_BDOOR_CLOSE);
  if (oneShotAutoMode) {
    currentState = IDLE;
    oneShotAutoMode = false;
  } else if (autoModeEnabled) {
    currentState = WEIGHING;
  } else {
    currentState = IDLE;
  }
#else
  stepperBurnDoor.moveTo(POS_BDOOR_CLOSE);
  if (stepperBurnDoor.distanceToGo() == 0 && stepperBurnDoor.currentPosition() == POS_BDOOR_CLOSE) {
    if (oneShotAutoMode) {
      currentState = IDLE;
      oneShotAutoMode = false;
    } else if (autoModeEnabled) {
      currentState = WEIGHING;
    }
      else {
      currentState = IDLE;
    }
  }
#endif
}



void handleFault() {
  emergencyStop();
  autoModeEnabled = false;
}


// --- FUNCTIONS ---
/* [Stepper Run Helper] */
void runAllSteppers() {
  if (currentState != FAULT) {
    stepperDoor.run();
    stepperPush.run();
    stepperAsh.run();
    stepperBurner.run();
    stepperBurnDoor.run();
    stepperMainConveyor.runSpeed();

  }
}


// --- FUNCTIONS ---
/* [Stepper Busy Flags Check] */
void checkStepperFlags() {
  if (motorDoorBusy      && stepperDoor.distanceToGo()   == 0) motorDoorBusy      = false;
  if (motorPushBusy      && stepperPush.distanceToGo()   == 0) motorPushBusy      = false;
  if (motorAshBusy       && stepperAsh.distanceToGo()    == 0) motorAshBusy       = false;
  if (motorBurnerBusy    && stepperBurner.distanceToGo() == 0) motorBurnerBusy    = false;
  if (motorBurnDoorBusy  && stepperBurnDoor.distanceToGo()== 0) motorBurnDoorBusy = false;
}


// --- SETUP ---
/* [Setup Function] */
/* ====== SETUP ====== */
void setup() {
  Serial.begin(9600);
  Serial2.begin(115200);
  // Serial1.setRxBufferSize(8192);
  Serial1.begin(460800);


#if USE_LIDAR
  
  for (int i = 0; i < 360; i++) {
    backgroundDist[i] = 0;
    currentScan[i] = 0;
  }

  Serial1.write(stopCmd, 2); 
  Serial1.write(startCmd, 2);

#endif 
  
  loadSettings();
  if (isnan(minBatchWeight) || burnerActiveTimeSec == 0 || burnerActiveTimeSec > 86400) {
    minBatchWeight = 5.0;
    burnerActiveTimeSec = 1; 
    tempSetpoint = 1200;
    saveSettings();
}

//  Validasi Awal
  if (isnan(minBatchWeight)) minBatchWeight = 5.0;
  if (burnerActiveTimeSec == 0) burnerActiveTimeSec = 30;

//
//  blower1.begin(NORMAL_MODE, ON);
//  blower2.begin(NORMAL_MODE, ON);
//  blower3.begin(NORMAL_MODE, ON);

//  Pins Init
//  pinMode(RELAY_FEEDER_MOTOR, OUTPUT);
//  pinMode(RELAY_WEIGHING_MOTOR, OUTPUT);
  pinMode(RELAY_BURNER, OUTPUT);
  pinMode(RELAY_IGNITION, OUTPUT);
  digitalWrite(RELAY_IGNITION, HIGH);

  pinMode(PIN_BLOWER_1, OUTPUT);
  pinMode(PIN_BLOWER_2, OUTPUT);
  pinMode(PIN_BLOWER_3, OUTPUT);

  pinMode(ENABLE_PIN, OUTPUT);
  digitalWrite(ENABLE_PIN, HIGH);

  pinMode(DATA_PIN, OUTPUT);
  pinMode(CLOCK_PIN, OUTPUT);
  pinMode(LATCH_PIN, OUTPUT);

#if USE_MAX31856
  SPI.begin();
  temperature = new MAX31856(MAX31856_SDI, MAX31856_SDO, MAX31856_CS, MAX31856_SCK);
  temperature->writeRegister(REGISTER_CR0, CR0_INIT);

#else
  currentTempC = 8.0;
  //Serial.println("STARTING SYSTEM");
#endif
#if USE_HX711
  scale.begin(HX711_DT, HX711_SCK);
  scale.set_scale(scale_factor);
  tareScale();
#endif
  nexInit();


  page0.attachPop(page0PopCallback, &page0);
  page1.attachPop(page1PopCallback, &page1);
  page2.attachPop(page2PopCallback, &page2);
  b1.attachPop(page2PopCallback, &b1);

  bTempUp.attachPop(bTempUpPopCallback, &bTempUp);
  bTempDown.attachPop(bTempDownPopCallback, &bTempDown);

  // 1. Dashboard Callbacks
  btAuto.attachPop(btAutoPopCallback, &btAuto);
  bStop.attachPop(bStopPopCallback, &bStop);
  bManStop.attachPop(bStopPopCallback, &bManStop);
  bsettingStop.attachPop(bStopPopCallback, &bsettingStop);

  nWeightSet.attachPop(nWeightSetPopCallback, &nWeightSet);
  nTimeSet.attachPop(nTimeSetPopCallback, &nTimeSet); 

  // 2. Manual Control Callbacks
  btManDir.attachPop(btManDirPopCallback, &btManDir);
  bManDoor.attachPop(bManDoorPopCallback, &bManDoor);
  bManBDoor.attachPop(bManBDoorPopCallback, &bManBDoor);
  bManBurn.attachPop(bManBurnPopCallback, &bManBurn);
  bManPush.attachPop(bManPushPopCallback, &bManPush);
  bManAsh.attachPop(bManAshPopCallback, &bManAsh);
  bManMainC.attachPop(bManMainCPopCallback, &bManMainC);
  
  hManSpeed.attachPop(hManSpeedPopCallback, &hManSpeed);
  hManStep.attachPop(hManStepPopCallback, &hManStep);
  
//  btManBlow.attachPop(btManBlowPopCallback, &btManBlow);
  btManIgn.attachPop(btManIgnPopCallback, &btManIgn);
  btManFeed.attachPop(btManFeedPopCallback, &btManFeed);
  btManWeigh.attachPop(btManWeighPopCallback, &btManWeigh);
  b0.attachPop(b0PopCallback, &b0);


  // 3. Settings Page Callbacks
  bTempUp.attachPop(bTempUpPopCallback, &bTempUp);
  bTempDown.attachPop(bTempDownPopCallback, &bTempDown);
  bTimeUp.attachPop(bTimeUpPopCallback, &bTimeUp);
  bTimeDown.attachPop(bTimeDownPopCallback, &bTimeDown);
  bWeightUp.attachPop(bWeightUpPopCallback, &bWeightUp);
  bWeightDown.attachPop(bWeightDownPopCallback, &bWeightDown);

  bSelDoor.attachPop(bSelDoorPopCallback, &bSelDoor);
  bSelBurn.attachPop(bSelBurnPopCallback, &bSelBurn);
  bSelFeed.attachPop(bSelFeedPopCallback, &bSelFeed);
  bSelBDoor.attachPop(bSelBDoorPopCallback, &bSelBDoor);
  bSelAsh.attachPop(bSelAshPopCallback, &bSelAsh);
  bSelMainC.attachPop(bSelMainCPopCallback, &bSelMainC);

  hSpeed.attachPop(hSpeedPopCallback, &hSpeed);
  hStep.attachPop(hStepPopCallback, &hStep);

  bBlow1.attachPop(bBlow1PopCallback, &bBlow1);
  bBlow2.attachPop(bBlow2PopCallback, &bBlow2);
//  bBlow3.attachPop(bBlow3PopCallback, &bBlow3);

  bSave.attachPop(bSavePopCallback, &bSave);
  bZero.attachPop(bZeroPopCallback, &bZero);

//  emergencyStop();
}


// --- MAIN LOOP ---
/* [Main Loop Function] */
/* ====== MAIN (Refactored) ====== */
void loop() {
  now = millis();
  nexLoop(nex_listen_list);

  // Hardware Run
  if (currentState != FAULT) {
  stepperDoor.run();
    stepperPush.run();
    stepperAsh.run();
    stepperBurner.run();
    stepperBurnDoor.run();
    stepperMainConveyor.runSpeed();

  }

  // Logic Blocks
  checkIgnitionPriming();
  checkStepperFlags();
  checkBurnerTimer();
  updateBlowerDimmer();
  checkFeederConveyor();


  // Periodic Update
  if (now - lastSensorMillis >= SENSOR_INTERVAL) {
    lastSensorMillis = now;
    readSensors();
    updateHMI();
    if (currentState == WEIGHING) {
      convertMassValueto7Segment(currentWeightKg);
    } else if (currentState == BURNING || currentState == IGNITING) {
      convertTemperatureValueto7Segment(currentTempC);
    } else {
      // misal: tampilkan suhu default
      convertTemperatureValueto7Segment(currentTempC);
    }
  }

  runStateMachine();
}
